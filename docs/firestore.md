<img align="right" width="30%" src="images/firestore-illo_1x.png">

<small>
<a href="https://github.com/angular/angularfire">AngularFire</a> &#10097; <a href="../README.md#developer-guide">Developer Guide</a> &#10097; Realtime Cloud Firestore
</small>
# 2. Documents in AngularFirestore

> Cloud Firestore is a NoSQL, document-oriented database. Unlike a SQL database, there are no tables or rows. Instead, you store data in *documents*, which are organized into *collections*.
Each *document* contains a set of key-value pairs. Cloud Firestore is optimized for storing large collections of small documents.

### [Go to collections querying](#collections-querying)
# Document querying
#### <p style="color:#16ab45"> This documentation is updated for modular version 9 of angular fire package. For previous or missing features refer to older docs.</p>

## Features list of document querying
1. Create a document
2. Update a document
3. Delete a document
4. Observer a document for changes
5. Inline querying like
  * Incrementing field value
  * Adding a data in an array
  * Removing a data from an array
6. Offline data persistence

## Create a document
### Create the document in a fixed document id

```ts
import { Component, OnInit } from '@angular/core';
import { Firestore } from '@angular/fire/firestore';
import { doc, getDoc } from 'firebase/firestore';

@Component({
  selector: "app-root",
  template: `
    <ul>
      <li *ngIf="data">
        {{ data.name }}
      </li>
    </ul>
  `,
})
export class AppComponent implements OnInit {
  data: any = {};
  constructor(private firestore: Firestore) {}
  ngOnInit() {
    getDoc(doc(this.firestore,'data/Pn5oHxAjpnSEAPJABj22')).then((data)=>{
      this.data = data.data();
    })
  }
}
```
### Add the document inside a collection

Here the document with data `{name:'Rick Roll'}` will be added to collection `data` with unique random id generated by firebase firestore
```ts
import { Component, OnInit } from '@angular/core';
import { Firestore } from '@angular/fire/firestore';
import { doc, addDoc } from 'firebase/firestore';

@Component({
  selector: "app-root",
  template: `<p>Check console</p>`,
})
export class AppComponent implements OnInit {
  constructor(private firestore: Firestore) {}
  ngOnInit() {
    addDoc(collection(this.firestore,'data'),{name:'Rick Roll'}).then((data)=>{
      console.log('Doc added');
    })
  }
}
```
## Update doc with new data
This method changes the data inside the document `mydoc` which is inside the collection `data` with he new data `{name:'Updated name is rick roll'}`
```ts
import { Component, OnInit } from '@angular/core';
import { Firestore } from '@angular/fire/firestore';
import { doc, updateDoc } from 'firebase/firestore';

@Component({
  selector: "app-root",
  template: `<p>Check console</p>`,
})
export class AppComponent implements OnInit {
  constructor(private firestore: Firestore) {}
  ngOnInit() {
    updateDoc(doc(this.firestore,'data/mydoc'),{name:'Updated name is rick roll'}).then((data)=>{
      console.log('Doc updated');
    })
  }
}
```
## Delete a doc
This method deletes the document `mydoc` which is inside the collection.
```ts
import { Component, OnInit } from '@angular/core';
import { Firestore } from '@angular/fire/firestore';
import { doc, deleteDoc } from 'firebase/firestore';

@Component({
  selector: "app-root",
  template: `<p>Check console</p>`,
})
export class AppComponent implements OnInit {
  constructor(private firestore: Firestore) {}
  ngOnInit() {
    deleteDoc(doc(this.firestore,'data/mydoc')).then((data)=>{
      console.log('Doc deleted');
    })
  }
}
```
## Get realtime updates on document data

This methods returns you a subscription from which you can subscribe and get the latest data whenever the document changes it's data.

```ts
import { Component, OnInit } from '@angular/core';
import { Firestore } from '@angular/fire/firestore';
import { doc, docData } from 'firebase/firestore';
import { Subscription } from 'rxjs';

@Component({
  selector: "app-root",
  template: `
    <h1>This data will change when data inside document changes </h1>
    <p>Data {{this.documentData}}</p>`,
})
export class AppComponent implements OnInit, OnDestroy {
  constructor(private firestore: Firestore) {}
  documentSubscription:Subscription = Subscription.EMPTY;
  documentData:any = {}
  ngOnInit() {
    this.documentSubscription = docData(doc(this.firestore, 'data/Pn5oHxAjpnSEAPJABj22')).subscribe(
      (data: any) => {
        this.documentData = data.data()
        console.log('Doc changed',data.data())
      }
    );
  }
}
```

## Inline Querying and data manipulation

### Incrementing field value

```ts
import { Component, OnInit } from '@angular/core';
import { Firestore } from '@angular/fire/firestore';
import { doc, docData } from 'firebase/firestore';
import { Subscription } from 'rxjs';

@Component({
  selector: "app-root",
  template: `<h1>Everytime you refresh the page your score increases by 4</h1>`,
})
export class AppComponent implements OnInit, OnDestroy {
  constructor(private firestore: Firestore) {}
  ngOnInit() {
    updateDoc(doc(this.firestore, 'data/Pn5oHxAjpnSEAPJABj22'), {score:increment(4)}).then(()=>{
      console.log('incremented');
    })
  }
}
```
Other field value functions are also accepted like
1. `increment(n)` Increments the specified value by n
2. `arrayRemove(n)` Removes the data n from a specified array
3. `arrayUnion(n)` Adds the data n to specified array


##Access data offline

Cloud Firestore supports offline data persistence. This feature caches a copy of the Cloud Firestore data that your app is actively using, so your app can access the data when the device is offline. You can write, read, listen to, and query the cached data. When the device comes back online, Cloud Firestore synchronizes any local changes made by your app to the Cloud Firestore backend.

To use offline persistence, you don't need to make any changes to the code that you use to access Cloud Firestore data. With offline persistence enabled, the Cloud Firestore client library automatically manages online and offline data access and synchronizes local data when the device is back online.
### Configure offline persistence

When you initialize Cloud Firestore, you can enable or disable offline persistence:

* For Android and Apple platforms, offline persistence is enabled by default. To disable persistence, set the `PersistenceEnabled` option to `false`.
* For the web, offline persistence is disabled by default. To enable persistence, call the enablePersistence method. Cloud Firestore's cache isn't automatically cleared between sessions. Consequently, if your web app

[For more info refer here](https://firebase.google.com/docs/firestore/manage-data/enable-offline)

This will enable persistence in your firestore database
In your `app.module.ts` file add this when initializing firestore
```ts
import { enableIndexedDbPersistence } from 'firebase/firestore';
import { provideFirestore,getFirestore } from '@angular/fire/firestore';

@NgModule({
  imports:[
    provideFirestore(()=>{
      const firestore = getFirestore();
      enableIndexedDbPersistence(firestore);
      return firestore
    }),
  ]
})
```
---
# Collections querying
#### <p style="color:#16ab45"> This documentation is updated for modular version 9 of angular fire package. For previous or missing features refer to older docs.</p>

> Cloud Firestore is a NoSQL, document-oriented database. Unlike a SQL database, there are no tables or rows. Instead, you store data in _documents_, which are organized into _collections_.
> Each _document_ contains a set of key-value pairs. Cloud Firestore is optimized for storing large collections of small documents.

## Using `AngularFirestoreCollection`

The `AngularFirestoreCollection` service is a wrapper around the native Firestore SDK's [`CollectionReference`](https://firebase.google.com/docs/reference/js/firebase.firestore.CollectionReference) and [`Query`](https://firebase.google.com/docs/reference/js/firebase.firestore.Query) types. It is a generic service that provides you with a strongly typed set of methods for manipulating and streaming data. This service is designed for use as an `@Injectable()`.

```ts
import { Component } from "@angular/core";
import { Subscription } from "rxjs";
import { collection, getDocs, QuerySnapshot } from "firebase/firestore";
import { Firestore } from "@angular/fire/firestore";
export interface Item {
  name: string;
}

@Component({
  selector: "app-root",
  template: `
    <ul>
      <li *ngFor="let item of items">
        {{ item.name }}
      </li>
    </ul>
  `,
})
export class AppComponent implements OnInit {
  items: Item[] = [];
  constructor(private firestore: Firestore) {}
  ngOnInit() {
    getDocs(collection(this.firestore, "data")).then(
      (querySnapshot: QuerySnapshot) => {
        this.items = [];
        querySnapshot.forEach((doc: any) => {
          this.items.push(doc.data());
        });
      }
    );
  }
}
```

## Streaming collection data or get realtime data

There are multiple ways of streaming collection data from Firestore.

1. `collectionSnapshots()` It is a method which returns a subscription with latest and complete list of documents in a collection.
2. `collectionChanges()` It is a method which returns a subscription with only the changed data in a collection.

## `collectionSnapshots()` Implementation example

```typescript
import { Component } from "@angular/core";
import { Subscription } from "rxjs";
import { collection } from "firebase/firestore";
import { collectionSnapshots, Firestore } from "@angular/fire/firestore";
export interface Item {
  name: string;
}

@Component({
  selector: "app-root",
  template: `
    <ul>
      <li *ngFor="let item of items">
        {{ item.name }}
      </li>
    </ul>
  `,
})
export class AppComponent implements OnInit, OnDestroy {
  itemListSubscription: Subscription = Subscription.EMPTY;
  items: Item[] = [];
  constructor(private firestore: Firestore) {}
  ngOnInit() {
    this.dataListSubscription = collectionSnapshots(
      collection(this.firestore, "data")
    ).subscribe((data) => {
      this.items = [];
      data.forEach((doc: any) => {
        this.items.push(doc.data());
      });
    });
  }
  ngOnDestroy(): void {
    this.itemListSubscription.unsubscribe();
  }
}
```

## `collectionChanges()` Implementation example

This method only returns data of a changed document so it can be used for keeping an eye on edits on any dataset. This is good method because you don't have to compare all data on the fly to know which one is new.

> Cool tip: It has the best use case when showing notifications. But remember

> <p style="color:#ff4f67;"> <strong>WARNING:</strong> It outputs every document last change present in the collection when it is first invoked or executed. </p>

```typescript
import { Component } from "@angular/core";
import { Subscription } from "rxjs";
import { collection } from "firebase/firestore";
import { collectionChanges, Firestore } from "@angular/fire/firestore";
export interface Item {
  name: string;
}

@Component({
  selector: "app-root",
  template: `
    <ul>
      <li *ngFor="let item of items">
        {{ item.doc.data().name }}
        <strong>Type: </strong>{{ item.type }} <strong>New Index: </strong
        >{{ item.newIndex }} <strong>Old Index: </strong>{{ item.oldIndex }}
      </li>
    </ul>
  `,
})
export class AppComponent implements OnInit, OnDestroy {
  itemListSubscription: Subscription = Subscription.EMPTY;
  items: Item[] = [];
  constructor(private firestore: Firestore) {}
  ngOnInit() {
    this.dataListSubscription = collectionChanges(
      collection(this.firestore, "data")
    ).subscribe((dataChange) => {
      this.items = [];
      dataChange.forEach((doc: any) => {
        this.items.push(doc.data());
      });
    });
  }
  ngOnDestroy(): void {
    this.itemListSubscription.unsubscribe();
  }
}
```

## Conditional collection querying

Cloud Firestore provides powerful query functionality for specifying which documents you want to retrieve from a collection or collection group. These queries can also be used with either `getDocs()` or `collectionSnapshots()`, as described in Get Data and Get Realtime Updates.

[More on queries refer here](https://firebase.google.com/docs/firestore/query-data/queries)

#### Simple example demonstrating functioning of queries.

```typescript
import { Component } from "@angular/core";
import { collection, getDocs, query, where } from "firebase/firestore";
import { Firestore } from "@angular/fire/firestore";
export interface Item {
  name: string;
  salary:number;
}

@Component({
  selector: "app-root",
  template: `
    <ul>
      <li *ngFor="let item of items">
        {{ item.name }}
      </li>
    </ul>
  `,
})
export class AppComponent implements OnInit {
  items: Item[] = [];
  constructor(private firestore: Firestore) {}
  ngOnInit() {
    getDocs(
      query(
        collection(this.firestore,'data'),
        where('salary', '>=', 400))).then(collections:any)=>{
        collections.forEach((doc:any)=>{
         this.items.push(doc.data())
        })
    })
  }
}
```
The where() method takes three parameters: a field to filter on, a comparison operator, and a value. Cloud Firestore supports the following comparison operators:

* `<` less than
* `<=` less than or equal to
* `==` equal to
* `\>` greater than
* `\>=` greater than or equal to
* `!=` not equal to
* `array-contains`
* `array-contains-any`
* `in`
* `not-in`


[Looking for more advanced queries](https://firebase.google.com/docs/firestore/query-data/queries#query_operators)

---
## Order and limit data with Cloud Firestore

Cloud Firestore provides powerful query functionality for specifying which documents you want to retrieve from a collection. These queries can also be used with either `getDocs()` or `collectionChanges()`, as described in Get Data.

### Order and limit data
By default, a query retrieves all documents that satisfy the query in ascending order by document ID. You can specify the sort order for your data using orderBy(), and you can limit the number of documents retrieved using limit().

For example, you could query for the first 3 cities alphabetically with:

```typescript
import { Component } from "@angular/core";
import { collection, getDocs, query, limit, where } from "firebase/firestore";
import { Firestore } from "@angular/fire/firestore";
export interface City {
  name: string;
}

@Component({
  selector: "app-root",
  template: `
    <ul>
      <li *ngFor="let city of cities">
        {{ city.name }}
      </li>
    </ul>
  `,
})
export class AppComponent implements OnInit {
  cities: City[] = [];
  constructor(private firestore: Firestore) {}
  ngOnInit() {
    getDocs(
      query(
        collection(this.firestore,'cities'),
        orderBy('name'),
        limit(10))).then((collections:any)=>{
          collections.forEach((doc:any)=>{
            console.log('Conditional',doc.data())
            this.cities.push(doc.data())
          })
    })
  }
}
```

[For more references and extra options visit full docs](https://firebase.google.com/docs/firestore/query-data/order-limit-data)

## Paginate data with query cursors
With query cursors in Cloud Firestore, you can split data returned by a query into batches according to the parameters you define in your query.

Query cursors define the start and end points for a query, allowing you to:

* Return a subset of the data.
* Paginate query results.

However, to define a specific range for a query, you should use the `where()` method described in Simple Queries.

### Add a simple cursor to a query

Use the `startAt()` or `startAfter()` methods to define the start point for a query. The `startAt()` method includes the start point, while the `startAfter()` method excludes it.

For example, if you use `startAt(A)` in a query, it returns the entire alphabet. If you use `startAfter(A)` instead, it returns `B-Z`.

```typescript
import { Component } from "@angular/core";
import { collection, getDocs, query, limit, where } from "firebase/firestore";
import { Firestore } from "@angular/fire/firestore";
export interface City {
  name: string;
  population:number;
}

@Component({
  selector: "app-root",
  template: `
    <ul>
      <li *ngFor="let city of cities">
        {{ city.name }}
      </li>
    </ul>
  `,
})
export class AppComponent implements OnInit {
  cities: City[] = [];
  constructor(private firestore: Firestore) {}
  ngOnInit() {
    getDocs(
      query(
        collection(this.firestore,'population'),
        orderBy("population"),
        startAt(1000000))).then((collections:any)=>{
          collections.forEach((doc:any)=>{
            this.cities.push(doc.data())
        })
    })
  }
}
```

> Now to paginate this query. You just need to get the length of current cities length(-1) and then use it inside `startAfter` function so that all the results will be after the last document

[Full example on pagination](https://firebase.google.com/docs/firestore/query-data/query-cursors#paginate_a_query)
