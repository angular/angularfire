import { join } from 'path';
import { spawn } from 'cross-spawn';
import { copy, writeFile } from 'fs-extra';

interface OverrideOptions {
  exportName?: string;
  zoneWrap?: boolean;
  blockUntilFirst?: boolean;
  override?: boolean;
}

function zoneWrapExports() {
  const reexport = async (
    module: string,
    name: string,
    path: string,
    exports: string[],
    overrides: Record<string, OverrideOptions | null> = {}
  ) => {
    const imported = await import(path);
    const toBeExported: [string, string, boolean][] = exports.
      filter(it => !it.startsWith('_') && overrides[it] !== null && overrides[it]?.override !== true).
      map(importName => {
        const zoneWrap = typeof imported[importName] === 'function' &&
          // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
          (overrides[importName]?.zoneWrap ?? importName[0] !== importName[0].toUpperCase());
        const exportName = overrides[importName]?.exportName ?? importName;
        return [importName, exportName, zoneWrap];
      });
    const zoneWrapped = toBeExported.filter(([, , zoneWrap]) => zoneWrap);
    const rawExport = toBeExported.filter(([, , zoneWrap]) => !zoneWrap);
    const overridden = Object.keys(overrides).filter(key => overrides[key]?.override);
    const isFirebaseSDK = path.startsWith('firebase/');
    const hasZoneWrappedFns = zoneWrapped.length > 0;
    const hasRawExportedFns = rawExport.length > 0;
    const hasOverridedFns = overridden.length > 0;
    const zoneWrappedImports = zoneWrapped.map(([importName]) => `${importName} as _${importName}`).join(',\n  ');
    const rawExportedFns = rawExport.map(([importName, exportName]) =>
      `${importName}${exportName === importName ? '' : `as ${exportName}`}`).join(',\n  ');
    const overriddenFns = overridden.join(',\n  ');
    const exportedZoneWrappedFns = zoneWrapped.map(([importName, exportName]) =>
      `export const ${exportName} = ɵzoneWrap(_${importName}, ${overrides[importName]?.blockUntilFirst ?? true});`)
        .join('\n');
    const filePath = join(process.cwd(), 'src', `${module}/${name}.ts`);
    // TODO(davideast): Create a builder pattern for this file for readability
    const fileOutput = `// DO NOT MODIFY, this file is autogenerated by tools/build.ts
${isFirebaseSDK ? `export * from '${path}';\n` : ''}${hasZoneWrappedFns ? `import { ɵzoneWrap } from '@angular/fire';
import {
  ${zoneWrappedImports}
} from '${path}';
` : ''}${!isFirebaseSDK && hasRawExportedFns ? `
export {
  ${rawExportedFns}
} from '${path}';
` : ''}${hasOverridedFns ? `
export {
  ${overriddenFns}
} from './overrides';
` : ''}
${exportedZoneWrappedFns}
`;
    await writeFile(filePath, fileOutput);
  };
  return Promise.all([
    reexport('analytics', 'firebase', 'firebase/analytics', ["getAnalytics", "initializeAnalytics", "isSupported", "logEvent", "setAnalyticsCollectionEnabled", "setCurrentScreen", "settings", "setUserId", "setUserProperties"], {
      isSupported: { override: true },
    }),
    reexport('app', 'firebase', 'firebase/app', ["deleteApp", "getApp", "getApps", "initializeApp", "onLog", "registerVersion", "setLogLevel", "FirebaseError", "SDK_VERSION"]),
    reexport('app-check', 'firebase', 'firebase/app-check', ["getToken", "initializeAppCheck", "onTokenChanged", "setTokenAutoRefreshEnabled", "CustomProvider", "ReCaptchaEnterpriseProvider", "ReCaptchaV3Provider"]),
    reexport('auth', 'rxfire', 'rxfire/auth', ["authState", "user", "idToken"]),
    reexport('auth', 'firebase', 'firebase/auth', ["applyActionCode", "beforeAuthStateChanged", "checkActionCode", "confirmPasswordReset", "connectAuthEmulator", "createUserWithEmailAndPassword", "deleteUser", "fetchSignInMethodsForEmail", "getAdditionalUserInfo", "getAuth", "getIdToken", "getIdTokenResult", "getMultiFactorResolver", "getRedirectResult", "initializeAuth", "isSignInWithEmailLink", "linkWithCredential", "linkWithPhoneNumber", "linkWithPopup", "linkWithRedirect", "multiFactor", "onAuthStateChanged", "onIdTokenChanged", "parseActionCodeURL", "reauthenticateWithCredential", "reauthenticateWithPhoneNumber", "reauthenticateWithPopup", "reauthenticateWithRedirect", "reload", "sendEmailVerification", "sendPasswordResetEmail", "sendSignInLinkToEmail", "setPersistence", "signInAnonymously", "signInWithCredential", "signInWithCustomToken", "signInWithEmailAndPassword", "signInWithEmailLink", "signInWithPhoneNumber", "signInWithPopup", "signInWithRedirect", "signOut", "unlink", "updateCurrentUser", "updateEmail", "updatePassword", "updatePhoneNumber", "updateProfile", "useDeviceLanguage", "verifyBeforeUpdateEmail", "verifyPasswordResetCode", "ActionCodeOperation", "ActionCodeURL", "AuthCredential", "AuthErrorCodes", "browserLocalPersistence", "browserPopupRedirectResolver", "browserSessionPersistence", "debugErrorMap", "EmailAuthCredential", "EmailAuthProvider", "FacebookAuthProvider", "FactorId", "GithubAuthProvider", "GoogleAuthProvider", "indexedDBLocalPersistence", "inMemoryPersistence", "OAuthCredential", "OAuthProvider", "OperationType", "PhoneAuthCredential", "PhoneAuthProvider", "PhoneMultiFactorGenerator", "prodErrorMap", "ProviderId", "RecaptchaVerifier", "SAMLAuthProvider", "SignInMethod", "TwitterAuthProvider"], {
      debugErrorMap: null,
      inMemoryPersistence: null,
      browserLocalPersistence: null,
      browserSessionPersistence: null,
      indexedDBLocalPersistence: null,
      prodErrorMap: null,
    }),
    reexport('database', 'rxfire', 'rxfire/database', ["fromRef", "ListenEvent", "ListenerMethods", "stateChanges", "list", "listVal", "auditTrail", "object", "objectVal", "changeToData"]),
    reexport('database', 'firebase', 'firebase/database', ["child", "connectDatabaseEmulator", "enableLogging", "endAt", "endBefore", "equalTo", "forceLongPolling", "forceWebSockets", "get", "getDatabase", "goOffline", "goOnline", "increment", "limitToFirst", "limitToLast", "off", "onChildAdded", "onChildChanged", "onChildMoved", "onChildRemoved", "onDisconnect", "onValue", "orderByChild", "orderByKey", "orderByPriority", "orderByValue", "push", "query", "ref", "refFromURL", "remove", "runTransaction", "serverTimestamp", "set", "setPriority", "setWithPriority", "startAfter", "startAt", "update", "Database", "DataSnapshot", "OnDisconnect", "QueryConstraint", "TransactionResult"]),
    reexport('firestore', 'rxfire', 'rxfire/firestore', ["collectionChanges", "collection", "sortedChanges", "auditTrail", "collectionData", "doc", "docData", "snapToData", "fromRef", "collectionCount", "collectionCountSnap"], {
      doc: { exportName: 'docSnapshots' },
      collection: { exportName: 'collectionSnapshots' },
    }),
    reexport('firestore', 'firebase', 'firebase/firestore', ["addDoc", "arrayRemove", "arrayUnion", "clearIndexedDbPersistence", "collection", "collectionGroup", "connectFirestoreEmulator", "deleteDoc", "deleteField", "disableNetwork", "doc", "documentId", "enableIndexedDbPersistence", "enableMultiTabIndexedDbPersistence", "enableNetwork", "endAt", "endBefore", "getDoc", "getDocFromCache", "getDocFromServer", "getDocs", "getDocsFromCache", "getDocsFromServer", "getFirestore", "increment", "initializeFirestore", "limit", "limitToLast", "loadBundle", "namedQuery", "onSnapshot", "onSnapshotsInSync", "orderBy", "query", "queryEqual", "refEqual", "runTransaction", "serverTimestamp", "setDoc", "setLogLevel", "snapshotEqual", "startAfter", "startAt", "terminate", "updateDoc", "waitForPendingWrites", "where", "writeBatch", "Bytes", "CACHE_SIZE_UNLIMITED", "CollectionReference", "DocumentReference", "DocumentSnapshot", "FieldPath", "FieldValue", "Firestore", "FirestoreError", "GeoPoint", "LoadBundleTask", "Query", "QueryConstraint", "QueryDocumentSnapshot", "QuerySnapshot", "SnapshotMetadata", "Timestamp", "Transaction", "WriteBatch", "getCountFromServer"]),
    reexport('functions', 'rxfire', 'rxfire/functions', ["httpsCallable"], {
      httpsCallable: { exportName: 'httpsCallableData' },
    }),
    reexport('functions', 'firebase', 'firebase/functions', ["connectFunctionsEmulator", "getFunctions", "httpsCallable", "httpsCallableFromURL"]),
    reexport('messaging', 'firebase', 'firebase/messaging', ["deleteToken", "getMessaging", "getToken", "isSupported", "onMessage"], {
      onMessage: { blockUntilFirst: false },
      isSupported: { override: true },
    }),
    reexport('remote-config', 'rxfire', 'rxfire/remote-config', ["getValue", "getString", "getNumber", "getBoolean", "getAll"], {
      getValue: { exportName: 'getValueChanges' },
      getString: { exportName: 'getStringChanges' },
      getNumber: { exportName: 'getNumberChanges' },
      getBoolean: { exportName: 'getBooleanChanges' },
      getAll: { exportName: 'getAllChanges' },
    }),
    reexport('remote-config', 'firebase', 'firebase/remote-config', ["activate", "ensureInitialized", "fetchAndActivate", "fetchConfig", "getAll", "getBoolean", "getNumber", "getRemoteConfig", "getString", "getValue", "isSupported", "setLogLevel"], {
      isSupported: { override: true },
    }),
    reexport('storage', 'rxfire', 'rxfire/storage', ["fromTask", "getDownloadURL", "getMetadata", "uploadBytesResumable", "uploadString", "percentage"], {
      getDownloadURL: null,
      getMetadata: null,
      uploadBytesResumable: null,
      uploadString: null,
    }),
    reexport('storage', 'firebase', 'firebase/storage', ["connectStorageEmulator", "deleteObject", "getBlob", "getBytes", "getDownloadURL", "getMetadata", "getStorage", "getStream", "list", "listAll", "ref", "updateMetadata", "uploadBytes", "uploadBytesResumable", "uploadString", "StringFormat"]),
    reexport('performance', 'rxfire', 'rxfire/performance', ["getPerformance$", "trace", "traceUntil", "traceWhile", "traceUntilComplete", "traceUntilFirst"], {
      getPerformance$: null,
      trace: null,
    }),
    reexport('performance', 'firebase', 'firebase/performance', ["getPerformance", "initializePerformance", "trace"]),
    reexport('firestore/lite', 'rxfire', 'rxfire/firestore/lite', ["collection", "collectionData", "doc", "docData", "snapToData", "fromRef"], {
      doc: { exportName: 'docSnapshots' },
      collection: { exportName: 'collectionSnapshots' },
    }),
    reexport('firestore/lite', 'firebase', 'firebase/firestore/lite', ["addDoc", "arrayRemove", "arrayUnion", "collection", "collectionGroup", "connectFirestoreEmulator", "deleteDoc", "deleteField", "doc", "documentId", "endAt", "endBefore", "getDoc", "getDocs", "getFirestore", "increment", "initializeFirestore", "limit", "limitToLast", "orderBy", "query", "queryEqual", "refEqual", "runTransaction", "serverTimestamp", "setDoc", "setLogLevel", "snapshotEqual", "startAfter", "startAt", "terminate", "updateDoc", "where", "writeBatch", "Bytes", "CollectionReference", "DocumentReference", "DocumentSnapshot", "FieldPath", "FieldValue", "Firestore", "FirestoreError", "GeoPoint", "Query", "QueryConstraint", "QueryDocumentSnapshot", "QuerySnapshot", "Timestamp", "Transaction", "WriteBatch"]),
  ]);
}

const src = (...args: string[]) => join(process.cwd(), 'src', ...args);
const dest = (...args: string[]) => join(process.cwd(), 'dist', '@angular/fire', ...args);
const destPacakges = (...args: string[]) => join(process.cwd(), 'dist/packages-dist', ...args);

const rootPackage = import(join(process.cwd(), 'package.json'));

async function replacePackageCoreVersion() {
  const root = await rootPackage;
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  const replace = require('replace-in-file');
  const files = destPacakges('package.json');
  return replace({
    files,
    from: 'ANGULARFIRE2_VERSION',
    to: root.version
  });
}

async function replaceSchematicVersions() {
  const root = await rootPackage;
  const packagesPath = destPacakges('schematics', 'versions.json');
  const dependencies = await import(packagesPath);
  Object.keys(dependencies.peerDependencies).forEach(name => {
    dependencies.peerDependencies[name].version = root.dependencies[name] || root.devDependencies[name];
  });
  Object.keys(dependencies.firebaseFunctionsDependencies).forEach(name => {
    dependencies.firebaseFunctionsDependencies[name].version = root.dependencies[name] || root.devDependencies[name];
  });
  return writeFile(packagesPath, JSON.stringify(dependencies, null, 2));
}

function spawnPromise(command: string, args: string[]) {
  return new Promise<void>((resolve, reject) => spawn(command, args, { stdio: 'inherit' }).on('close', code => {
    if (code === 0) {
      resolve()
    } else {
      reject('Build failed.');
    }
  })
  .on('error', reject));
}

async function compileSchematics() {
  await spawnPromise(`npx`, ['tsc', '-p', src('schematics', 'tsconfig.json')]);
  return Promise.all([
    copy(src('schematics', 'builders.json'), dest('schematics', 'builders.json')),
    copy(src('schematics', 'collection.json'), dest('schematics', 'collection.json')),
    copy(src('schematics', 'migration.json'), dest('schematics', 'migration.json')),
    copy(src('schematics', 'deploy', 'schema.json'), dest('schematics', 'deploy', 'schema.json')),
    copy(src('schematics', 'add', 'schema.json'), dest('schematics', 'add', 'schema.json')),
    copy(src('schematics', 'setup', 'schema.json'), dest('schematics', 'setup', 'schema.json')),
    replaceSchematicVersions()
  ]);
}

async function buildLibrary() {
  await zoneWrapExports();
  await spawnPromise('npx', ['ng', 'build']);
  await Promise.all([
    copy(join(process.cwd(), '.npmignore'), dest('.npmignore')),
    copy(join(process.cwd(), 'README.md'), dest('README.md')),
    copy(join(process.cwd(), 'docs'), dest('docs')),
    compileSchematics(),
    replacePackageCoreVersion(),
  ]);
}

buildLibrary().catch(err => {
  console.error(err);
  process.exit(1);
})
